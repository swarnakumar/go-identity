// Code generated by sqlc. DO NOT EDIT.
// source: audits.sql

package sqlc

import (
	"context"
)

const getChanges = `-- name: GetChanges :many
SELECT id, email, updated_by, pwd, is_active, is_admin, created_at FROM user_changes ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type GetChangesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetChanges(ctx context.Context, arg GetChangesParams) ([]*UserChange, error) {
	rows, err := q.db.Query(ctx, getChanges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserChange
	for rows.Next() {
		var i UserChange
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UpdatedBy,
			&i.Pwd,
			&i.IsActive,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesCount = `-- name: GetChangesCount :one
SELECT COUNT(*) FROM user_changes
`

func (q *Queries) GetChangesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getChangesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getChangesCountForUser = `-- name: GetChangesCountForUser :one
SELECT COUNT(*) FROM user_changes WHERE email = $1
`

func (q *Queries) GetChangesCountForUser(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getChangesCountForUser, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getChangesEarliestFirst = `-- name: GetChangesEarliestFirst :many
SELECT id, email, updated_by, pwd, is_active, is_admin, created_at FROM user_changes ORDER BY created_at LIMIT $1 OFFSET $2
`

type GetChangesEarliestFirstParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetChangesEarliestFirst(ctx context.Context, arg GetChangesEarliestFirstParams) ([]*UserChange, error) {
	rows, err := q.db.Query(ctx, getChangesEarliestFirst, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserChange
	for rows.Next() {
		var i UserChange
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UpdatedBy,
			&i.Pwd,
			&i.IsActive,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesForUser = `-- name: GetChangesForUser :many
SELECT id, email, updated_by, pwd, is_active, is_admin, created_at FROM user_changes WHERE email = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type GetChangesForUserParams struct {
	Email  string `json:"email"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetChangesForUser(ctx context.Context, arg GetChangesForUserParams) ([]*UserChange, error) {
	rows, err := q.db.Query(ctx, getChangesForUser, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserChange
	for rows.Next() {
		var i UserChange
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UpdatedBy,
			&i.Pwd,
			&i.IsActive,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesForUserEarliestFirst = `-- name: GetChangesForUserEarliestFirst :many
SELECT id, email, updated_by, pwd, is_active, is_admin, created_at FROM user_changes WHERE email = $1 ORDER BY created_at LIMIT $2 OFFSET $3
`

type GetChangesForUserEarliestFirstParams struct {
	Email  string `json:"email"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetChangesForUserEarliestFirst(ctx context.Context, arg GetChangesForUserEarliestFirstParams) ([]*UserChange, error) {
	rows, err := q.db.Query(ctx, getChangesForUserEarliestFirst, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserChange
	for rows.Next() {
		var i UserChange
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UpdatedBy,
			&i.Pwd,
			&i.IsActive,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletions = `-- name: GetDeletions :many
SELECT id, email, deleted_by, deleted_at FROM user_deletions ORDER BY deleted_at DESC LIMIT $1 OFFSET $2
`

type GetDeletionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetDeletions(ctx context.Context, arg GetDeletionsParams) ([]*UserDeletion, error) {
	rows, err := q.db.Query(ctx, getDeletions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserDeletion
	for rows.Next() {
		var i UserDeletion
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DeletedBy,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletionsCount = `-- name: GetDeletionsCount :one
SELECT COUNT(*) FROM user_deletions
`

func (q *Queries) GetDeletionsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getDeletionsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFailedLoginAttemptsForUser = `-- name: GetFailedLoginAttemptsForUser :many
SELECT id, email, success, login_time FROM login_attempts
WHERE email = $1 AND success = FALSE
ORDER BY login_time DESC
LIMIT $2 OFFSET $3
`

type GetFailedLoginAttemptsForUserParams struct {
	Email  string `json:"email"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetFailedLoginAttemptsForUser(ctx context.Context, arg GetFailedLoginAttemptsForUserParams) ([]*LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttemptsForUser, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LoginAttempt
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Success,
			&i.LoginTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsForUser = `-- name: GetLoginAttemptsForUser :many
SELECT id, email, success, login_time FROM login_attempts
WHERE email = $1
ORDER BY login_time DESC
LIMIT $2 OFFSET $3
`

type GetLoginAttemptsForUserParams struct {
	Email  string `json:"email"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetLoginAttemptsForUser(ctx context.Context, arg GetLoginAttemptsForUserParams) ([]*LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttemptsForUser, arg.Email, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LoginAttempt
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Success,
			&i.LoginTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerLoginAttempt = `-- name: RegisterLoginAttempt :exec
INSERT INTO login_attempts (email, success, login_time) VALUES ($1, $2, now())
`

type RegisterLoginAttemptParams struct {
	Email   string `json:"email"`
	Success bool   `json:"success"`
}

func (q *Queries) RegisterLoginAttempt(ctx context.Context, arg RegisterLoginAttemptParams) error {
	_, err := q.db.Exec(ctx, registerLoginAttempt, arg.Email, arg.Success)
	return err
}
